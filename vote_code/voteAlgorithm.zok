from "ecc/babyjubjubParams" import BABYJUBJUB_PARAMS;
import "ecc/edwardsScalarMult" as mul;
import "hashes/sha256/sha256Padded";
import "hashes/sha256/512bit" as hash;
import "hashes/utils/256bitsDirectionHelper" as multiplex;
import "ecc/babyjubjubParams.code" as context;
import "ecc/edwardsScalarMult.code" as mull;
import "ecc/edwardsAdd" as add;
 
//设置Merkle tree
//DEPTH：Merkle tree深度，即代表选民数量的大小2^12
const u32 DEPTH =12;
//候选人的数量
const u32 N = 5;
//Vote算法
def main(private bool[N][256] VoteArra, u8[4] coin,
 bool[DEPTH] condition1, u32[8] left1, u32[DEPTH][8] path1,
 private bool[N][256] r, field[N][2] pk, private field[2] sk)->(field[20][2], u32[8], u32[8]) {	
    //设置Merkle树   
    u32[8] mut root = left1;
	// Loop up the tree
    for u32 i in 0..DEPTH {
	    (u32[8], u32[8]) s = (condition1[i] ? path1[i] : left1, condition1[i] ? left1 : path1[i]);
	    root = hash(s.0, s.1);
        //assert (digest == root1);
    }
    //生成序列号SN
    u32[8] sn = sha256Padded(coin);
    //谓词条件判定
	field  mut sum=0;
	field mut vector1 = 0;
	bool mut res_2=true;
       //res=if (a[i]==0||a[i]==1)&&res {true} else {false};
    field mut vot1 = 0;
    field mut vot = 0;
    for u32 i in 0..N{
        for u32 j in 0..256{
            vot1 = if VoteArra[i][j] == false {0} else {1};
            vot = vot + vot1;
        }
        assert(vot==0||vot==1);
    }
	sum = sum + vot;
	res_2=if sum==1 {true} else {false};
    assert (res_2);
    //对候选人进行加密
    field[20][2] mut Ct = [[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]];
    field[2] G = [16540640123574156134436876038791482806971768689494387082833631921987005038935,
	20819045374670962167435360035096875258406992893633759881276124905556507972311];
    u32 mut k = 0;
    for u32 i in 0..N{
        Ct[k] = mull(r[i],G,context());
        k=k+1;
        Ct[k] = add(mull(r[i],pk[0],context()), mull(VoteArra[0],G,context()),BABYJUBJUB_PARAMS);
        k = k+1;
    }
    return (Ct,sn,root);
}